<!DOCTYPE html>
<html lang="en">
<head>

  <!--

  Now that you're looking at this, do you want to grab a coffee and talk about future opportunities?
  Message me at sean@smgoodrich.com

  I Look forward to meeting you!

  Thanks,
  Sean
    ______     ______     ______     ______
   /\  ___\   /\  ___\   /\  __ \   /\   \ \
   \ \___  \  \ \  __\   \ \  __ \  \ \ \ \ \
    \/\_____\  \ \_____\  \ \_\ \_\  \ \_\___\
     \/_____/   \/_____/   \/_/\/_/   \/_/___/

  -->

    <title>Sean Goodrich</title>
    <link rel="shortcut icon" type="image/x-icon" href="images/favicon.ico"/>
    <meta charset="utf-8">
    <meta name="description" content="Welcome to my personal website! I am a Software Engineer currently working at Amazon Web Services and living in Seattle.">
    <meta name="author" content="Sean Goodrich">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="keywords" content="Sean, Goodrich, UM, Michigan, Computer, Science, Los, Angeles, LA">

    <script type="text/javascript" src="projectInfo.js"></script>
    <script type="text/javascript" src="portfolioVideo.js"></script>
    <script type="text/javascript" src="portfolioPopover.js"></script>
    <script type="text/javascript" src="links.js"></script>

    <link rel="stylesheet" type="text/css" href="css/MainStyleSheet.css" />
    <link rel="stylesheet" type="text/css" href="css/jquery.fullPage.css" />

    <script src="js/three.min.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/tween.min.js"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.9.1/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/jquery.slimscroll.min.js"></script>
    <script type="text/javascript" src="js/jquery.fullPage.js"></script>

</head>
<body>

		<div id ="container"></div>

        <div id = "continue" class="footer">
        	Scroll &#9661 Down
        </div>

        <div id="fullpage">

            <div class="section " id="section0">
            </div>

            <div class="section" id="section1">
            </div>

            <div class="section" id="section2">
                <img id="signature" src="images/signature_white.png"/>
                <div id ="bottom">
        		</div>
            </div>

        </div>

        <div id = "instructions" class="footer">
        	Drag to spin projects. Hover to play. Click for more info.
        </div>

<script type="text/javascript">

		var scroll_height;
		var scrolling = false;
		var explode = false;
		var stop_logo = true;
		var current_page;

		var touchScrollHeight;
		var touchScrolled;

		var portfolio_loaded = false;
		var loaded_pg2 = false;
		var loaded_pg3 = false;

		var portfolioClass;
        var portfolioPopover;
        var linksClass;

		$(document).ready(function() {
			page1 = new S_Logo();
			page2 = new Portfolio();
			create_Logo();
			page2.init();

			$('#fullpage').fullpage({

				sectionsColor: ['#000000', '#282828', '#33383D'],

				navigation: true,

				navigationPosition: 'right',

	        	scrollingSpeed: 1000,

				navigationTooltips: ['Logo', 'Portfolio', 'Connect'],

				 'onLeave': function(index, nextIndex, direction)
				 	{
					scrolling = true;
					if (index == 1)
						{
						ExplodeFunction();
						$("#continue").fadeOut(function()
							{
							if (nextIndex == 2)
									$("#instructions").fadeIn();
							});

							if (nextIndex == 2)
								{
								setTimeout(function(){ portfolioClass.portfolioAppear(250); }, 2000);
								//actualRotation = targetRotation= = 0;
								loaded_pg2 = true;
								}
							else if (nextIndex == 3)
								{
								linksClass.linksAppear(250);
								loaded_pg3 = true;
								window.setTimeout(function(){linksClass.showLinks = true;}, 250 * 7);
								}
						}
					else if (index == 2)
						{
						page2.noHoverPortfolio();

						$("#instructions").fadeOut(function()
							{
							if (nextIndex == 1)
								$("#continue").fadeIn();
							});

						if (nextIndex == 3 && loaded_pg3 == false)
							{
							loaded_pg3 = true;
							linksClass.linksAppear(250);
							window.setTimeout(function(){linksClass.showLinks = true;}, 250 * 7);
							}
						}
					else
						{
						page2.noHoverLinks();

						if (nextIndex == 1)
							$("#continue").fadeIn();
						else if (nextIndex == 2)
							{
							$("#instructions").fadeIn();
							if (loaded_pg2 == false)
								{
								loaded_pg2 = true;
								portfolioClass.portfolioAppear(250);
								//actualRotation = targetRotation= = 0;
								}
							}
						}

					if (nextIndex == 1)
						{
						create_Logo();
						loaded_pg2 = false;
						portfolioClass.hidePortfolio(250);
						}
					else if (portfolio_loaded == false)
						{
						page2.animate();
						portfolio_loaded = true;
						}
       				},

				'afterLoad': function(anchorLink, index){
					scrolling = false;
					current_page = index;

					if (index == 2){
						page2.mousePortfolio();
					} else if (index == 3){
						page2.mouseIcon();
					}
       			}
			});

			// Add actions to the arrows
			$('#continue').on('click touchstart', function() {
				$.fn.fullpage.moveSectionDown();
			});

			function create_Logo ()	{
				explode = false;
				$( "#container" ).empty();

				page1.init();

				if (stop_logo  == true)
					{
					stop_logo = false;
					page1.animate();
					}

				document.getElementById("container").style.top = "0px";
				document.getElementById("continue").style.bottom = "2%";
				}


			function ExplodeFunction () {
					explode = true;
					portfolioClass.resetPortfolio();
					setTimeout(function(){
						if (explode == true)
							{
							stop_logo = true;
							$( "#container" ).empty();
							}
					}, 2000);
			}

			setInterval(function ()
				{
				var node = document.getElementById("fullpage");
				scroll_height = -1 * node.getBoundingClientRect().top; //real offset top
				}, 20);

			function onDocumentTouchStart( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					touchScrollHeight = event.touches[ 0 ].pageY;
					touchScrolled = false;
				}
			}

			function onDocumentTouchMove( event ) {
				if ( event.touches.length === 1 && touchScrolled == false && $("#info_page").is(':hidden') ) {
					event.preventDefault();
					if(touchScrollHeight - event.touches[ 0 ].pageY > 50) {
						$.fn.fullpage.moveSectionDown();
						touchScrolled = true;
					} else if (touchScrollHeight - event.touches[ 0 ].pageY < -50) {
						$.fn.fullpage.moveSectionUp();
						touchScrolled = true;
					}
				}
			}

			document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			var doScroll = function (event) {
				event.preventDefault();
				event = window.event || event;

				var delta = event.wheelDeltaY;
				if (Math.abs(delta) < 100 || $("#info_page").is(':visible') )
					$.fn.fullpage.setMouseWheelScrolling(false);
				else
					$.fn.fullpage.setMouseWheelScrolling(true);
				/*
				event.preventDefault();
				event = window.event || event;

				var delta = event.wheelDeltaY;
				console.log(delta);
				if (delta > 100 && changePage == false) {
					$.fn.fullpage.moveSectionUp();
					changePage = true;
				}
				else if (delta < -100 && changePage == false) {
					$.fn.fullpage.moveSectionDown();
					changePage = true;
				}

				clearTimeout(wheeling);
				wheeling = setTimeout(function() {
					console.log('stop wheeling!');
					wheeling = undefined;
					changePage = false;
				}, 50);
				*/

			};

			window.addEventListener('mousewheel', doScroll, false);
			//window.addEventListener('DOMMouseScroll', doScroll, false);


		});

</script>

<script>
    var S_Logo = function(){

			var group;
			var container;
			var particlesData = [];
			var camera, scene, renderer;
			var positions,colors;
			var pointCloud;
			var particlePositions;
            var linesMesh;
            var particleCount;

			var maxParticleCount = 500;
			var sHeight = 800;
			var rHalf = sHeight / 2;
			var collision_rad = 100;
			var minDistance = 60;
			var flipped = 1;

			function init() {
				particlesData = [];
				particleCount = 10;

				container = document.getElementById("container");

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / (window.innerHeight), 1, 10000 );
				camera.position.z = 1300;

				scene = new THREE.Scene();

				group = new THREE.Group();
				scene.add( group );

				var segments = maxParticleCount * maxParticleCount;

				positions = new Float32Array( segments * 3 );
				colors = new Float32Array( segments * 3 );

				var pMaterial = new THREE.PointCloudMaterial({
					color: 0xFFFFFF,
					size: 5,
					blending: THREE.AdditiveBlending,
					transparent: true,
					sizeAttenuation: true
				});

				particles = new THREE.BufferGeometry();
				particlePositions = new Float32Array( maxParticleCount * 3 );

				for ( var i = 0; i < maxParticleCount; i++ ) {
					var y = (Math.random() * 4/3 * sHeight) - (2/3 * sHeight);
					var x = 0;
					if (y>rHalf)
						{
						y = y - rHalf/3;
						x = 15*Math.sqrt(rHalf-y) + (Math.random() * 2 * collision_rad - collision_rad);
						}
					else if (y< -rHalf)
						{
						y = y + rHalf/3;
						x = -15*Math.sqrt(rHalf+y) + (Math.random() * 2 * collision_rad - collision_rad);
						}
					else
						x = (-Math.sin(y * Math.PI / rHalf) * rHalf/2) + (Math.random() * 2 * collision_rad - collision_rad);

					var z = Math.random() * collision_rad - collision_rad/2;

					particlePositions[ i * 3     ] = x;
					particlePositions[ i * 3 + 1 ] = y;
					particlePositions[ i * 3 + 2 ] = z;

					// add it to the geometry
					particlesData.push( {
						velocity: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5,  Math.random() - 0.5),
						numConnections: 0
					} );

				}

				particles.drawcalls.push( {
					start: 0,
					count: particleCount,
					index: 0
				} );

				particles.addAttribute( 'position', new THREE.DynamicBufferAttribute( particlePositions, 3 ) );

				// create the particle system
				pointCloud = new THREE.PointCloud( particles, pMaterial );
				group.add( pointCloud );

				var geometry = new THREE.BufferGeometry();

				geometry.addAttribute( 'position', new THREE.DynamicBufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'color', new THREE.DynamicBufferAttribute( colors, 3 ) );

				geometry.computeBoundingSphere();

				geometry.drawcalls.push( {
					start: 0,
					count: 0,
					index: 0
				} );

				var material = new THREE.LineBasicMaterial( {
					vertexColors: THREE.VertexColors,
					blending: THREE.AdditiveBlending,
					transparent: true
				} );

				linesMesh = new THREE.Line( geometry, material, THREE.LinePieces );
				group.add( linesMesh );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setClearColor( 0xffffff, 0 ); // the default
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight);

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / (window.innerHeight);
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight);

                $.fn.fullpage.reBuild();
			}

			function animate() {

				var vertexpos = 0;
				var colorpos = 0;
				var numConnected = 0;

				if (particleCount < maxParticleCount){
					particleCount+=10;
					particles.drawcalls[ 0 ].count = particleCount;
				}

				for ( var i = 0; i < particleCount; i++ ) {
					particlesData[ i ].numConnections = 0;
				}

				for ( var i = 0; i < particleCount; i++ ) {

					// get the particle
					var particleData = particlesData[i];

					particlePositions[ i * 3     ] += particleData.velocity.x;
					particlePositions[ i * 3 + 1 ] += particleData.velocity.y;
					particlePositions[ i * 3 + 2 ] += particleData.velocity.z;

					xPos = particlePositions[ i * 3];
					yPos = particlePositions[ i * 3 +1];
					zPos = particlePositions[ i * 3 +2];

					xVel = particleData.velocity.x;
					yVel = particleData.velocity.y;
					zVel = particleData.velocity.z;

					if (explode == true)
						{
						particleData.velocity.x *= 1.07;
						particleData.velocity.y *= 1.07;
						particleData.velocity.z *= 1.07;

						if (scroll_height > window.innerHeight)
							{
							document.getElementById("container").style.top = window.innerHeight - scroll_height + "px";
							document.getElementById("continue").style.bottom = -0.98 * window.innerHeight + scroll_height + "px" ;
							}
						}

					else
						{
						if (Math.abs(xPos) > rHalf/Math.PI)
							particleData.velocity.x = -xVel;

						if (Math.abs(yPos) > rHalf)
							particleData.velocity.y = -yVel;

						if (Math.abs(zPos) > collision_rad)
							particleData.velocity.z = -zVel;

						// boundary conditions for top quadratic part of S
						if (xPos > 0 && yPos > rHalf/2 && yPos < 2*rHalf/3)
									{
									particleData.velocity.y = -yVel;
									}
						else if (xPos > 0 && yPos > 2*rHalf/3)
									{
									var estimated_width = 15*Math.sqrt(rHalf-yPos);
									var rad_quad = Math.abs(xPos - estimated_width);
									if (rad_quad > collision_rad)
										{
										parallel_vector = -15/(2*Math.sqrt(rHalf-yPos));
										normal_vector = -1 / parallel_vector;
										normal_norm = Math.sqrt(Math.pow(normal_vector,2) + 1);
										normal_x = 1 / normal_norm;
										normal_y = normal_vector / normal_norm;

										dot_product = -2 * (xVel * normal_x + yVel * normal_y);

										particleData.velocity.x = dot_product * normal_x + xVel;
										particleData.velocity.y = dot_product * normal_y + yVel;

										if (rad_quad > (1.1 * collision_rad))
											{
											particlePositions[ i * 3] = estimated_width;
											}
										}
									}
							// boundary conditions for bottom quadratic part of S
							else if (xPos < 0 && yPos < -rHalf/2 && yPos > -2*rHalf/3)
									{
									particleData.velocity.y = -yVel;
									}
							else if (xPos < 0 && yPos < -2*rHalf/3)
									{
									var estimated_width = -15*Math.sqrt(rHalf+yPos);
									var rad_quad = Math.abs(xPos - estimated_width);
									if (rad_quad > collision_rad)
										{
										parallel_vector = -15/(2*Math.sqrt(rHalf+yPos));
										normal_vector = -1 / parallel_vector;
										normal_norm = Math.sqrt(Math.pow(normal_vector,2) + 1);
										normal_x = 1 / normal_norm;
										normal_y = normal_vector / normal_norm;

										dot_product = -2 * (xVel * normal_x + yVel * normal_y);

										particleData.velocity.x = dot_product * normal_x + xVel;
										particleData.velocity.y = dot_product * normal_y + yVel;

										if (rad_quad > (1.1 * collision_rad))
											{
											particlePositions[ i * 3] = estimated_width;
											}
										}
									}
							// boundary conditions for middle Sin Wave part of S
							else
									{
									var expected_width = -Math.sin(yPos * Math.PI / rHalf) * rHalf/2;
									var rad_sin = Math.abs(xPos - expected_width);
									if (rad_sin > collision_rad)
										{
										parallel_vector = -Math.cos(yPos * Math.PI / rHalf);
										normal_vector = -1 / parallel_vector;
										normal_norm = Math.sqrt(Math.pow(normal_vector,2) + 1);
										normal_x = 1 / normal_norm;
										normal_y = normal_vector / normal_norm;

										dot_product = -2 * (xVel * normal_x + yVel * normal_y);

										particleData.velocity.x = dot_product * normal_x + xVel;
										particleData.velocity.y = dot_product * normal_y + yVel;

										if (rad_sin > (1.1 * collision_rad))
											{
											particlePositions[ i * 3] = expected_width;
											}
										}
									}
						}

					// Check collision
					for ( var j = i + 1; j < particleCount; j++ ) {

						var particleDataB = particlesData[ j ];

						var dx = particlePositions[ i * 3     ] - particlePositions[ j * 3     ];
						var dy = particlePositions[ i * 3 + 1 ] - particlePositions[ j * 3 + 1 ];
						var dz = particlePositions[ i * 3 + 2 ] - particlePositions[ j * 3 + 2 ];
						var dist = Math.sqrt( dx * dx + dy * dy + dz * dz );

						if ( dist < minDistance ) {

							particleData.numConnections++;
							particleDataB.numConnections++;

							var alpha = 1.0 - dist / minDistance;

							positions[ vertexpos++ ] = particlePositions[ i * 3     ];
							positions[ vertexpos++ ] = particlePositions[ i * 3 + 1 ];
							positions[ vertexpos++ ] = particlePositions[ i * 3 + 2 ];

							positions[ vertexpos++ ] = particlePositions[ j * 3     ];
							positions[ vertexpos++ ] = particlePositions[ j * 3 + 1 ];
							positions[ vertexpos++ ] = particlePositions[ j * 3 + 2 ];

							// need to account for x position
							if (flipped * particlePositions[ i * 3 + 1 ] < ( 1042 * (scroll_height/window.innerHeight - 47/400)) - 400)
								alpha = (40 / 255) * (1-alpha) + alpha;

							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;

							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;

							numConnected++;
						}
					}
				}


				linesMesh.geometry.drawcalls[ 0 ].count = numConnected * 2;
				linesMesh.geometry.attributes.position.needsUpdate = true;
				linesMesh.geometry.attributes.color.needsUpdate = true;

				pointCloud.geometry.attributes.position.needsUpdate = true;

				if (stop_logo == false)
					{
					requestAnimationFrame( animate );
					render();
					}
			}

			function render() {

				var time = Date.now() * 0.00015;

				if (time%4 > 0.5 && time%4 < 2.5)
					flipped = 1;
				else
					flipped = -1;


				if (time%4 < 1)
					{
					group.rotation.y = (1-Math.pow(Math.sin(time%2 * Math.PI/2),2)) * Math.PI;
					group.rotation.x = (1-Math.pow(Math.sin(time%2 * Math.PI/2),2)) * Math.PI;
					flipped = -1 * Math.cos(time%4 * Math.PI);
					}
				else if (time%4 < 2)
					{
					group.rotation.y = 0;
					group.rotation.x = 0;
					flipped = 1;
					}
				else if (time%4 < 3)
					{
					group.rotation.y = Math.pow(Math.sin(time%2 * Math.PI/2),2) * Math.PI;
					group.rotation.x = Math.pow(Math.sin(time%2 * Math.PI/2),2) * Math.PI;
					flipped = Math.cos(time%4 * Math.PI);
					}
				else
					{
					group.rotation.y = Math.PI;
					group.rotation.x = Math.PI;
					flipped = -1
					}

				renderer.render( scene, camera );

			}

			 return {
				"init": init,
				"animate":animate
			 };

		}

	var Portfolio = function(){

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
			var camera, scene, renderer;
			var mouseX = 0;
			var mouseY = 0;

			var controls;
			var objects = [];

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
			mouse.x = windowHalfX; //preset to big number so raycast doesn't initialize video onload
			mouse.y = windowHalfY; //preset to big number so raycast doesn't initialize video onload

			var actualRotation = 0;
			var targetRotation = 0;
			var targetRotationOnMouseDown = 0;
			var mouseXOnMouseDown = 0;

			function init() {

                scene = new THREE.Scene();

                portfolioClass = new lib_3D_portfolio(scene);
                portfolioPopover = new lib_portfolio_popover();
                linksClass = new lib_3D_links(scene);

				container = document.createElement('div');
				container.id = "container2";
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 3000;
				camera.position.y = 2050*(1.5 - scroll_height/window.innerHeight);
				camera.position.x = 0;

				var light = new THREE.DirectionalLight( 0xffffff, 0.8 );
				light.position.set(0.2, 0, 1 ).normalize();
				scene.add( light );

				var ambient = new THREE.AmbientLight(0x222222);
				scene.add( ambient );

				for ( var i = 0; i < project_info.length; i++ ) {
					portfolioClass.createMesh(project_info[i], i);
				}

 				renderer = new THREE.WebGLRenderer( { alpha: true } );
				renderer.setSize( window.innerWidth, window.innerHeight);
				container.appendChild( renderer.domElement );

                linksClass.createIcon(linksClass.facebookGeometry(), 0x3B5998, -500, 400 , 1000, "https://www.facebook.com/sean.m.goodrich");
                linksClass.createIcon(linksClass.linkedInGeometry(), 0x007bb6, 175, 400 , 1000, "https://www.linkedin.com/in/smgoodrich");
                linksClass.createIcon(linksClass.githubGeometry(), 0xffffff, -500, 0 , 1000, "https://github.com/smgood");
                linksClass.createIcon(linksClass.spotifyGeometry(), 0x1DB954, 175, 0 , 1000, "https://open.spotify.com/user/smgoodrich");
                linksClass.createIcon(linksClass.resumeGeometry(), 0xbda27e, -500, -400 , 1000, "./resume/resume_sean_goodrich.pdf");
                linksClass.createIcon(linksClass.emailGeometry(), 0xff6666, 175, -400 , 1000, "mailto:sean@smgoodrich.com");

                var pointLight = new THREE.PointLight( 0xffffff, 0.3, 2500 );
                pointLight.position.set(-162.5, -800 , 0);
                scene.add( pointLight );

				raycaster = new THREE.Raycaster();

				renderer.autoClear = false;

				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				window.addEventListener( 'resize', onWindowResize, false );

				document.addEventListener( 'touchstart', touchIcon, false );
				document.addEventListener( 'touchstart', touchPortfolio, false );
				document.addEventListener( 'mousemove', mouseIcon, false );
				document.addEventListener( 'mousemove', mousePortfolio, false );

				renderer.setClearColor( 0x000000, 0 ); // the default
			}


			var box_clicked = false;
			var down_clicked;
			var start_position;

			// stuff to do with the portfolio info
			$( document ).ready(function() {
				$( 'body' ).click(function(){
						if (current_link != null)
							{
							window.open(current_link.link, '_blank');
							}
				});
				$("#close").click(function()
					{
					$("#opacity_page").fadeOut();
					$("#info_page").fadeOut();
					document.addEventListener( 'mousedown', onDocumentMouseDown, false );
					});
			});

			function onMouseMove( event ) {
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight);

                $.fn.fullpage.reBuild();

                windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
                portfolioPopover.resize();
			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

  				if (current_mesh != null)
					{
					box_clicked = true;
					down_clicked = current_mesh;
					start_position = mouseX;

					timeout = setInterval(function(e)
						{
						if (current_mesh != down_clicked || Math.abs(start_position - mouseX) > 30)
							{
							box_clicked = false;
							clearInterval(timeout);
							}
						}, 50);
					}
			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.008;

			}

			function onDocumentMouseUp( event ) {
				event.preventDefault();
				if (box_clicked == true)
						{
						clearInterval(timeout);
						box_clicked = false;
						document.removeEventListener( 'mousedown', onDocumentMouseDown, false );

						// 1st number represents number of inputs
						var current_project = down_clicked.info;

                        portfolioPopover.projectDescription(current_project);

						$("#photo").one("load", function()
							{
								portfolioPopover.resize();
								$("#opacity_page").fadeIn();
								$("#info_page").fadeIn();
							}).attr("src", "images/" + current_project.image);
						}

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentMouseOut( event ) {
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentTouchStart( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;
				}
			}

			function onDocumentTouchMove( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.008;
				}
			}

		function animate() {
				camera.position.y = 2050*(1.5 - scroll_height/window.innerHeight);
				requestAnimationFrame( animate );
				TWEEN.update();
				render();
			}

			var current_mesh = null;
			var current_link = null;

			function render() {

				if (current_page == 2)
					{
					actualRotation += ( targetRotation - actualRotation ) * 0.05;
					portfolioClass.portfolio_container.rotation.y = actualRotation;
					}
				else
					{
					actualRotation = actualRotation%(2*Math.PI);
					targetRotation = 0;
					}


				renderer.clear();
				renderer.render( scene, camera );
			}

			function noHoverPortfolio()
				{
						document.body.style.cursor = "default";
						if (current_mesh != null)
							{
							current_mesh.material.color.set( 0xAAAAAA );
							current_mesh.video.pause();
							current_mesh = null;
							}
				}

			function noHoverLinks()
				{
						document.body.style.cursor = "default";
						if (current_link != null)
							{
							current_link.rotation.y = 0;
							current_link.position.z = 0;

							current_link = null;
							}
				}

			function mousePortfolio(event) {
				if (current_page == 2 && !scrolling) {
					// update the picking ray with the camera and mouse position
					raycaster.setFromCamera( mouse, camera );

					// calculate objects intersecting the picking ray
					var intersects = raycaster.intersectObjects( portfolioClass.portfolio_container.children );

					if (intersects.length > 0 && $("#info_page").is(':hidden') && intersects[0].point.z > 0)
							{
							document.body.style.cursor = "pointer";
							if (intersects[0].object != current_mesh)
								{
								if (current_mesh != null)
									{
									current_mesh.material.color.set( 0xAAAAAA );
									current_mesh.video.pause();
									}

								current_mesh = intersects[0].object;
								current_mesh.material.color.set( 0xffffff );
								current_mesh.video.play();
								}
							}
						else
							{
							noHoverPortfolio();
							}
				}
			}

			function touchPortfolio( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					var touchPos = new THREE.Vector2();
					touchPos.x = ( event.touches[ 0 ].pageX / window.innerWidth ) * 2 - 1;
					touchPos.y =  - ( event.touches[ 0 ].pageY / window.innerHeight ) * 2 + 1;
					raycaster.setFromCamera(touchPos, camera );

					var intersects = raycaster.intersectObjects( portfolioClass.portfolio_container.children );

					if (intersects.length > 0 && $("#info_page").is(':hidden') && intersects[0].point.z > 0)
						{
						if (intersects[0].object != current_mesh)
							{
							if (current_mesh != null)
								{
								current_mesh.material.color.set( 0xAAAAAA );
								current_mesh.video.pause();
								}

							current_mesh = intersects[0].object;
							current_mesh.material.color.set( 0xffffff );
							current_mesh.video.play();
							}
						}
					else
						{
						noHoverPortfolio();
						}
				}
			}

			function touchIcon( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					var touchPos = new THREE.Vector2();
					touchPos.x = ( event.touches[ 0 ].pageX / window.innerWidth ) * 2 - 1;
					touchPos.y =  - ( event.touches[ 0 ].pageY / window.innerHeight ) * 2 + 1;
					raycaster.setFromCamera(touchPos, camera );

					// calculate objects intersecting the picking ray
					var intersects = raycaster.intersectObjects(linksClass.links_container.children);

					if (intersects.length > 0 && linksClass.showLinks == true)
							{
							if (intersects[0].object != current_link)
								{
								if (current_link != null)
									{
									current_link.rotation.y = 0;
									current_link.position.z = 0;
									}

								current_link = intersects[0].object;

								if (current_link.position.x < 0)
									{
									current_link.rotation.y = Math.PI * 0.1;
									current_link.position.z = 100;
									}
								else
									{
									current_link.rotation.y = Math.PI * -0.1;
									current_link.position.z = 250;
									}
								}
							else
								{
								var open = window.open(current_link.link, '_blank');
								if (open == null || typeof(open)=='undefined')
									alert("New window blocked. Please visit:\n" + current_link.link);
								}
							}
					else
							{
							noHoverLinks();
							}
				}
			}

			function mouseIcon (event) {
				if (current_page == 3 && !scrolling) {
					// update the picking ray with the camera and mouse position
					raycaster.setFromCamera( mouse, camera );

					var intersects = raycaster.intersectObjects(linksClass.links_container.children);

					if (intersects.length > 0 && linksClass.showLinks == true)
							{
							document.body.style.cursor = "pointer";
							if (intersects[0].object != current_link)
											{
											if (current_link != null)
												{
												current_link.rotation.y = 0;
												current_link.position.z = 0;
												}

											current_link = intersects[0].object;

											if (current_link.position.x < 0)
												{
												current_link.rotation.y = Math.PI * 0.1;
												current_link.position.z = 100;
												}
											else
												{
												current_link.rotation.y = Math.PI * -0.1;
												current_link.position.z = 250;
												}
											}
							}
					else
							{
							noHoverLinks();
							}
				}
			}

			return {
				"init": init,
				"animate":animate,
				"noHoverLinks":noHoverLinks,
				"noHoverPortfolio":noHoverPortfolio,
				"mousePortfolio": mousePortfolio,
				"mouseIcon": mouseIcon
			};
		}
</script>

</body>
</html>
