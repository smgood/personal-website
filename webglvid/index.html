<!DOCTYPE html>
<!-- saved from url=(0066)http://alteredqualia.com/three/examples/webgl_materials_video.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>three.js webgl - materials - video</title>
		<meta charset="utf-8">
	
    
    
    
<style>
			body {
				background-color: #000000;
				margin: 0;
				font-family: Helvetica, sans-serif;;
				overflow: hidden;
			}
</style>
        
	</head>
	<body>

		<script src="js/three.min.js"></script>
		<script src="js/tween.min.js"></script>
		<script src="js/TrackballControls.js"></script>
		<script src="js/CSS3DRenderer.js"></script>

		<script type="text/javascript" src="js/ThreeExtrasVideo.js"></script>
		<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>

		<video id="video" autoplay loop style="display:none">
			<source src="textures/Burst.mp4" type="video/mp4">
		</video>
                
		<script type="text/javascript">
			
			var videos = [
				"Woven.mp4",
				"SmartArt.mp4",
				"MarketU.mp4",
				"Groom.mp4",
				"DrumCircle.mp4",
				"CommndGame.mp4",
				"Coalman.mp4",
				"CityPaperBox.mp4",
				"Burst.mp4",
				"Brickbreaker.mp4",
				"3dwebsite.mp4",
				"3dwebsite.mp4",
				"3dwebsite.mp4",
				"3dwebsite.mp4",
				"3dwebsite.mp4",
				"3dwebsite.mp4"
			];
			
			if ( ! THREE.Detector.webgl ) THREE.Detector.addGetWebGLMessage();

			var container;
			var camera, scene, renderer;
			var video, texture, material;
			var mouseX = 0;
			var mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var meshes = [],
				materials = [];
			
			var video_vect = [];
			var texture_vect = [];

			var controls;
			var objects = [];
			var helix = [];

			init();
			animate();
			

			function init() {

				container = document.createElement('div');
				document.body.appendChild( container );

				camera = new THREE.Camera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 3000;

				scene = new THREE.Scene();
				
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set(-0.5, 0, 1 );
				light.position.normalize();
				scene.addLight( light );
				
				
				for ( var i = 0; i < videos.length; i++ ) {
					var vidoe = document.createElement('video');
					var source = document.createElement('source'); 
					source.type = "video/mp4";
					source.src = "textures/" + videos[i];
					vidoe.appendChild(source);
					
					vidoe.autoplay=true;
					vidoe.loop=true;
					vidoe.muted=true;
					vidoe.id="video" + i;
					
					video_vect [i] = vidoe;
				}
				
				
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				
				
				for (var i = 0; i < video_vect.length; i++ )
					{
					video = video_vect [i];
					
					texture = new THREE.Texture( video );
					texture.min_filter = THREE.LinearFilter;
					texture.mag_filter = THREE.LinearFilter;
					texture_vect [i] = texture;
	
					var  geometry, xsize, ysize;
					xsize = 500;
					ysize = 500;
	
					var parameters = { color: 0xffffff, map: texture },
					material_base = new THREE.MeshLambertMaterial( parameters );
	
					renderer.initMaterial( material_base, scene.lights);
									
					geometry = new Cube( xsize, ysize, xsize/10 );
					change_uvs( geometry, xsize, ysize );
					
					materials[ i ] = new THREE.MeshLambertMaterial( parameters );
					
					material = materials[ i ];
					
					material.program = material_base.program;
					material.uniforms = Uniforms.clone( THREE.ShaderLib[ 'lambert' ].uniforms );
					
					var mesh = new THREE.Mesh( geometry, material );
					
										
					var phi = (i * Math.PI/4);
					mesh.position.x = 800 * Math.sin( phi );
					// cylinder
					mesh.position.y = - ( Math.floor(i/8) * 640 ) + 350;
					mesh.position.z = 800 * Math.cos( phi );
				
					mesh.rotation.y = (phi);
					
					mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
					meshes[ i ] = mesh;
					scene.addObject(meshes[ i ]);
				}

				renderer.autoClear = false;

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			}
			
			function change_uvs( geometry, width, height) {
				
				var i, j, uv, unitx, unity, offsetx, offsety;
				
				for ( i = 0; i < geometry.uvs.length; i++ ) {
					unitx = 1;
					unity = 1;
					offsetx = 0;
					offsety = 0;
					
					if (i == 0) //left
						{
						unitx = 0;
						offsetx = 0;
						}
					else if (i == 1) // right
						{
						unitx = 1;
						offsetx = width;
						}
					else if (i ==2) // top
						{
						unity = 0;
						offsety = 0;	
						}
					else if (i == 3) // bottom
						{
						unity = 1;
						offsety = height;	
						}
						
					uv = geometry.uvs[ i ];

					for ( j = 0; j < uv.length; j++ ) {
						uv[j].u = ( uv[j].u + offsetx ) * unitx;
						uv[j].v = ( uv[j].v + offsety ) * unity;
					}
				}
			}
			
			
			function onDocumentMouseMove(event) {
				mouseX = ( event.clientX - windowHalfX ) * 5;
				mouseY = ( event.clientY - windowHalfY ) * 5;		
			}

			//
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
				
			var first_frame = [];			
			function render() {
				
				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

				for (var i = 0; i < video_vect.length; i++ )
					{
					var video = video_vect [i];
					if ( video.readyState === video.HAVE_ENOUGH_DATA && first_frame[i] != true )
						{
						var texture = texture_vect [i];
						if ( texture ) 
							{
							texture.needsUpdate = true;
							first_frame[i] = true;
							}
						}
					}
					
				renderer.clear();
				renderer.render( scene, camera );		
			}
			
		</script>
</body></html>